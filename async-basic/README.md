# 코루틴의 이해

- [코루틴과 태스크로 작업하기 위한 asyncio api](https://docs.python.org/ko/3/library/asyncio-task.html)
- [좋은 블로그](https://it-eldorado.tistory.com/159#:~:text=Python%EC%97%90%EC%84%9C%20%EC%84%9C%EB%B8%8C%20%EB%A3%A8%ED%8B%B4%EA%B3%BC,%ED%95%98%EB%A9%B4%20%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%B4%20%EB%90%9C%EB%8B%A4.&text=%EA%B7%B8%EB%A6%AC%EA%B3%A0%20%EC%9D%B4%EB%A6%84%EC%97%90%EC%84%9C%20%EC%95%8C%20%EC%88%98,%EC%9D%80%20%EB%B9%84%EB%8F%99%EA%B8%B0%20%ED%95%A8%EC%88%98%EB%9D%BC%EA%B3%A0%EB%8F%84%20%EB%B6%80%EB%A5%B8%EB%8B%A4.)

## 비동기 프로그래밍

> 비동기(Asynchronous)라는 것은 쉽게 말해서 어떠한 작업이 완료되기를 기다리지 않고, 그 시간 동안 다른 작업을 하는 것을 말한다.

일반적인 Python 프로그램은 동기(Synchronous) 함수로만 이뤄져 있기 때문에, 항상 어떠한 작업이 완료되기를 기다린 후에 그다음 작업을 진행하게 된다. 하지만 Python에서도 코루틴을 이용하면 비동기 코드를 작성할 수 있기 때문에, 코루틴을 비동기 함수라고도 부르는 것이다

치킨 배달 예시

- [비동기 프로그래밍이란?](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous/Concepts)

## 코루틴

> 코루틴을 이용하면 파이썬 프로그램에서 동시에 많은 함수를 실행하는 것처럼 보이게 할 수 있다.
> "코루틴을 사용한 프로그래밍은 병렬 프로그래밍이다"의 명제는 거짓입니다.

- 메인루틴 : 코드의 메인 흐름
- 코루틴은 서브루틴(우리가 알고 있는 보통의 함수)의 더 일반화된 형태이다.

  - 프로그램이 실행되면 서브루틴은 별도의 공간(스코프)에 해당 로직들을 모아 놓고 있다.
  - 서브루틴이 호출이 될 때, 해당하는 로직들이 저장된 메모리로 이동했다가 return을 통해 원래 호출 시점으로 돌아오게 된다.

- 코루틴은 서브루틴처럼 해당 로직들을 별도의 공간에 모아 놓고 있다는 점은 동일하다.

- 코루틴은 서브루틴과 달리 해당 로직들이 진행되는 중간에 멈추어서 특정 위치로 돌아갔다가 다시 원래 위치로 돌아와 나머지 로직을 수행할 수 있다.

- 코루틴의 종류 (서브루틴 형태랑 유사함)

  - 제너레이터를 기반으로한 코루틴 -> 제너레이터 기반 코루틴 함수
  - async 키워드를 기반으로한 코루틴 -> 코루틴 함수 (버전 3.5부터)

- 코루틴 객체 : 코루틴 함수를 호출하여 반환된 객체

> 파이썬에서 코루틴은 제너레이터를 기반으로 구현된다.

- 파이썬 3.5 이전 버전에서는 코루틴을 직접 제너레이터 기반으로 작성해야 했다. async 키워드는 제너레이터 기반의 코루틴을 쉽게 사용할 수 있도록 돕는 문법적 설탕이다.

## 병행성, 동시성 (concurrency)

- 컴퓨터가 여러 작업(테스크)을 동시에 처리하는 것처럼 수행하는 것을 말한다.

  - 시분할 시스템

- CPU 코어가 하나인 컴퓨터에서 운영체제는 프로그램을 빠르게 변경하여 프로그램들이 마치 동시에 실행하는 것처럼 보이게 한다.

- 단일 프로그램 안에서 병행성이라는 도구를 사용하여 별개의 여러 실행 경로를 동시에 독립적으로 실행하는 것처럼 진행하게 한다.

## 병렬성 (parallelism)

- 실제로 여러 작업(테스크)을 동시에 실행하는 것이다.
- 각 CPU 코어가 각각 다른 프로그램의 명령어를 실행하여 각 프로그램이 같은 순간에 실행하도록 한다.

## 동기 함수를 코루틴처럼 쓰기 : loop.run_in_executor() 메소드

우리가 지금까지 알아본 원리에 따르면, 결국 비동기 프로그래밍의 효과를 보기 위해서는 현재의 쓰레드 실행과 무관하게 다른 곳에서 어떠한 작업을 할 수 있어야 한다. 그 대표적인 예시가 Sleep 혹은 I/O 관련 코루틴이었다. Sleep의 경우에는 이벤트 루프가 자체적으로 타이머를 가지고 있기 때문에, 그리고 I/O 관련 코루틴은 CPU가 열심히 일하는 동안 I/O 장치가 일해주면 되기 때문에 현재의 실행 흐름을 Block 하지 않고 다른 작업을 먼저 할 수 있었던 것이다.

그런데 사실 Python이 가지고 있는 대부분의 API는 동기 방식으로 동작한다. 애초에 동기 방식으로 동작하도록 설계된 언어이기 때문이다. 예를 들어, asyncio.sleep() 함수가 제공되기 전에는 time.sleep() 함수를 사용했는데, 이는 현재의 실행 흐름을 Block 하는 함수였다. 그리고 requests 라이브러리가 제공하는 requests.get(), requests.post() 등의 함수도 현재의 실행 흐름을 Block 하는 함수이다. 이러한 함수들을 이용해서는 비동기 프로그래밍이 불가능할 듯하다. 비동기 프로그래밍이 가능하려면 그러한 작업을 다른 어딘가에 맡겨 놓고 퓨처 객체를 await 하면서 현재 실행 중인 태스크의 제어를 이벤트 루프에게 넘겨야 하기 때문이다.

이때 사용하는 것이 바로 loop.run_in_executor() 메소드이다. loop는 이벤트 루프 객체이다. 어렵게 설명하면 한도 끝도 없겠지만, 간단하게 얘기해서 이 메소드는 동기 함수를 별도의 쓰레드에서 실행시킴으로써 마치 Sleep 혹은 I/O 관련 코루틴처럼 사용할 수 있게 해주는 것이다. 비동기 프로그래밍을 하려면 어떤 작업을 '다른 어딘가(= 별도의 쓰레드)'에 맡겨야 하기 때문이다.

이 함수의 사용 방법을 바로 한 번 알아보자. 이 함수의 반환 값은 퓨처 객체이기 때문에, await 키워드의 뒤에 올 수 있다.
